package ca.waterloo.dsg.graphflow;

import ca.waterloo.dsg.graphflow.graph.Graph;
import ca.waterloo.dsg.graphflow.graph.TypeAndPropertyKeyStore;
import ca.waterloo.dsg.graphflow.query.executors.ShortestPathExecutor;
import ca.waterloo.dsg.graphflow.query.executors.csp.ContinuousShortestPathsExecutor;
import ca.waterloo.dsg.graphflow.query.parser.StructuredQueryParser;
import ca.waterloo.dsg.graphflow.query.planner.ContinuousShortestPathPlanner;
import ca.waterloo.dsg.graphflow.query.plans.ContinuousDiffBFSShortestPathPlan;
import ca.waterloo.dsg.graphflow.query.plans.ContinuousShortestPathPlan;
import ca.waterloo.dsg.graphflow.query.structuredquery.StructuredQuery;
import org.antlr.v4.runtime.misc.Pair;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;

import java.io.*;
import java.util.*;

/**
 * This class is used to find the shortest path queries between N pair of vertices
 * in a loaded dataset.
 *
 */
public class EvaluatePathQueries {

    private static String ARG_BASE_DIR = "baseDir";

    //
    //This is the base directory for dataset files. I need to change it to be a parameter.
    // The default is set to either khaled's or Semih's machine for easy debug.
    //
    private static String DEFAULT_ARG_BASE_DIR = "/Users/khaled/dataset/";

    private static String ARG_GRAPH_FILE_TO_LOAD = "graphFileToLoad";
    private static String DEFAULT_ARG_GRAPH_FILE_TO_LOAD = "soc-Epinions1-90.txt";

    private static String ARG_RESULT_FILE = "resultFile";
    private static String DEFAULT_ARG_RESULT_FILE = "shortest_path_pairs.txt";

    private static String ARG_NUM_QUERIES = "numQueries";
    private static String DEFAULT_ARG_NUM_QUERIES = "1000";


    private static String ARG_SEED_FIND_PAIRS = "edgeWeightSeed";
    private static String DEFAULT_ARG_SEED_FIND_PAIRS = "8881453";

    private static String ARG_WEIGHTED = "weighted";
    private static String DEFAULT_ARG_WEIGHTED = "false";



    private Random srcDestRand;
    private String baseDir = "";
    private String graphFileToLoad = "";
    private int numQueries;
    private boolean isWeighted;
    private ExecutorType executorType;


    // Update queries!
    private List<EdgeBatch> data = new ArrayList<>();
    private List<Long> batchTimes = new LinkedList<>();
    private List<List<Double>> srcDstDistances = new LinkedList<>();
    private short vertexTypeId;
    private short edgeTypeId;
    private boolean printDistances;

    public enum ExecutorType {
        UNW_BASELINE,
        W_BASELINE;

        private static ExecutorType getFromCommandLineName(String commandLineName) {
            switch (commandLineName) {
                case "unw-baseline":
                    return UNW_BASELINE;
                case "w-baseline":
                    return W_BASELINE;
                default:
                    throw new IllegalArgumentException("Unknown continuous sp executor type: "
                        + commandLineName);
            }
        }
    }

    private EvaluatePathQueries(String baseDir, String graphFileToLoad, ExecutorType executorType,
                                int numQueries, int srcDestSeed, boolean isWeighted, boolean printDistances) {

        this.baseDir = baseDir;
        this.graphFileToLoad = graphFileToLoad;
        this.executorType = executorType;
        this.numQueries = numQueries;
        this.srcDestRand = new Random(srcDestSeed);
        this.isWeighted = isWeighted;
        if( isWeighted ) {
            Graph.IS_WEIGHTED = true;
        }
        this.printDistances = printDistances;
        vertexTypeId = TypeAndPropertyKeyStore.getInstance().
            mapStringTypeToShortOrInsert("VERTEX");
        edgeTypeId = TypeAndPropertyKeyStore.getInstance().
            mapStringTypeToShortOrInsert("WEIGHT");
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Experiment Parameters:\n").append("baseDir:" + baseDir).
            append(" graphFileToLoad: " + graphFileToLoad).
            append(" executorType: " + executorType).append("\nnumQueries: " + numQueries).
            append(" srcDestRand: " + srcDestRand).append(" isWeighted: " + isWeighted);
        return sb.toString();
    }

    private void loadInitial() throws NumberFormatException, IOException {
        Graph graph = Graph.getInstance();
        InputStreamReader in = new InputStreamReader(new FileInputStream(
            new File(this.baseDir + this.graphFileToLoad)));
        BufferedReader buffer = new BufferedReader(in);
        String line;
        int edgesCount = 0;
        int errorsCount = 0;
        long beginTime = System.nanoTime();

        while ((line = buffer.readLine()) != null) {
            if (line.isEmpty()) {
                continue;
            }

            String[] parts = line.split("\t");
            int expectedLength = (this.isWeighted) ? 3 : 2;
            if (parts.length != expectedLength) {
                errorsCount++;
                continue;
            }
            int fromVertex = Integer.parseInt(parts[0]);
            int toVertex = Integer.parseInt(parts[1]);
            Double weight;
            if( isWeighted ) {
                weight = Double.parseDouble(parts[2]);
                graph.addEdgeTemporarily(fromVertex, toVertex, vertexTypeId, vertexTypeId, weight, edgeTypeId);
            } else {
                graph.addEdgeTemporarily(fromVertex, toVertex, vertexTypeId, vertexTypeId, edgeTypeId);
            }
            edgesCount++;
            if (edgesCount % 100000 == 0) {
                long t2 = System.nanoTime();
                System.out.println(edgesCount + " loaded in " + (t2 - beginTime) / 1000000.0);
                beginTime = t2;
            }
        }
        graph.finalizeChanges();
        System.out.println("Initial Edges prepared and added\t" + edgesCount + "\t" +
            errorsCount + " edges ignored due to " + "incorrect format.");
        buffer.close();
    }


    private void applyBatchesAndMeasure() {
        int addedEdgeCount = 0;
        int deletedEdgeCount = 0;
        long beginTime = System.nanoTime();
        int numBatchesProcessed = 0;
        System.out.println("DATA SIZE: " + data.size());


        // loop on update batches
        for (EdgeBatch edgeBatch : data) {
            // loop in the batch
            for (int j = 0; j < edgeBatch.currentEdgeIndex; j++) {
                // Process Add edge!
                if (edgeBatch.type[j] == BatchType.ADDITION) {
                    Graph.INSTANCE.addEdgeTemporarily(edgeBatch.fromVertexId[j], edgeBatch.toVertexId[j], (short) -1,
                      (short) -1, (short) -1);
                    addedEdgeCount++;

                // Process Delete Edge
                } else if(edgeBatch.type[j] == BatchType.DELETION) {
                    Graph.INSTANCE.deleteEdgeTemporarily(edgeBatch.fromVertexId[j], edgeBatch.toVertexId[j], (short) -1);
                    deletedEdgeCount++;

                // Process Update Edge
                } else if(edgeBatch.type[j] == BatchType.UPDATE) {
                    Graph.INSTANCE.addEdgeTemporarily(edgeBatch.fromVertexId[j], edgeBatch.toVertexId[j],
                        vertexTypeId, vertexTypeId, edgeBatch.weight[j], edgeTypeId);
                }
            }

            // After applying all changes to the graph, finalize changes and run algorithms!

            /**
             * Finalize changes for executors of type:
             * 1- UNW_BASELINE
             * 2- W_BASELINE
             * 3- DIJKSTRA
             *
             */

            if (ExecutorType.UNW_BASELINE == executorType || ExecutorType.W_BASELINE ==
                executorType || ExecutorType.DIJKSTRA == executorType) {
                Graph.INSTANCE.finalizeChanges();
            }


            // Start running the queries!
            long batchStartTime = System.nanoTime();
            ContinuousShortestPathsExecutor.getInstance().execute();
            long batchEndTime = System.nanoTime();
            batchTimes.add(batchEndTime - batchStartTime);


            /**
             * Finalize changes for executors of the remaining types, but then do nothing!
             *
             */

            if (ExecutorType.UNW_BASELINE != executorType || ExecutorType.W_BASELINE !=
                executorType || ExecutorType.DIJKSTRA == executorType) {
                Graph.INSTANCE.finalizeChanges();
            }
            numBatchesProcessed++;
            if (numBatchesProcessed % 1000 == 0) {
                System.out.println(String.format("finished %s batches", numBatchesProcessed));
            }
            // UNCOMMENT THE CODE BELOW TO WRITE DOWN DISTANCES
//          List<Double> distances = new LinkedList<>();
//          for (ContinuousShortestPathPlan shortestPathPlan : ContinuousShortestPathsExecutor.getShortestPathPlans()) {
//              distances.add(shortestPathPlan.getSrcDstDistance());            
//          }
//          srcDstDistances.add(distances);
        }
        System.out.println("time to process all batches (ms) = "
            + (System.nanoTime() - beginTime) / 1000000.0 + " ms");
        System.out.println("Edges processed (added + deleted)\t" + (addedEdgeCount +
            deletedEdgeCount) + " (" + addedEdgeCount + " + " + deletedEdgeCount + ")");
    }


    /**
     *
     *
     *
     * @throws IOException
     */
    private void prepareAndRegisterContinuousShortestPathQueries() throws IOException {
        String[] continuousSPQueries = new String[numQueries];
        List<Pair<Integer, Integer>> srcDstPairs = getQueries();


        for (int i = 0; i < numQueries; i++) {
            Pair<Integer, Integer> query = srcDstPairs.get(i);
            int source = query.a;
            int destination = query.b;
            if(isWeighted) {
                continuousSPQueries[i] = "CONTINUOUSLY SHORTEST PATH (" + source + ", " + destination
                    + ") WEIGHTS ON WEIGHT FILE 'gym'";
            } else {
                continuousSPQueries[i] = "CONTINUOUSLY SHORTEST PATH (" + source + ", " + destination
                    + ") FILE 'gym'";
            }

            System.out.println(String.format("*** query %s: %s", i, continuousSPQueries[i]));
        }
        StructuredQuery[] structuredQueries = new StructuredQuery[numQueries];
        for (int i = 0; i < numQueries; i++) {
            structuredQueries[i] = new StructuredQueryParser().parse(continuousSPQueries[i]);
        }

        for (int i = 0; i < numQueries; i++) {
            ContinuousShortestPathsExecutor.getInstance().addShortestPathPlan(
                (ContinuousShortestPathPlan) new ContinuousShortestPathPlanner(structuredQueries[i])
                        .plan(executorType, backtrack));
        }
    }

    /**
     * Prepare a list of queries using a predefined random seed value: srcDestRand
     *
     * @return A list of queries, each represented as pair<int>
     * @throws IOException
     */
    private List<Pair<Integer, Integer>> getQueries() throws IOException {


        // Prepare connected queries, add them to the buffer
        List<Pair<Integer, Integer>> pathQueries = new ArrayList<>();

        for (int i=0;i<numQueries;i++){
            pathQueries.add(Pair<int,int>(this.srcDestRand.nextInt(this.)))
        }
        this.srcDestRand





        BufferedReader brConnected = new BufferedReader(new InputStreamReader(new FileInputStream(
            new File(this.baseDir + this.connectedQueryFile))));
        String line;
        String[] split;
        while ((line = brConnected.readLine()) != null) {
            split = line.split("\\s+");
            connectedQueries.add(new Pair<Integer, Integer>(Integer.parseInt(split[0]),
                Integer.parseInt(split[1])));
        }
        brConnected.close();

        // Prepare disconnected queries, add them to the buffer
        List<Pair<Integer, Integer>> disconnectedQueries = new ArrayList<>();
        System.out.println("DisConnectedQueryFile: " + disconnectedQueryFile);
        BufferedReader brDisconnected = new BufferedReader(new InputStreamReader(new FileInputStream(
            new File(this.baseDir + this.disconnectedQueryFile))));
        while ((line = brDisconnected.readLine()) != null) {
            split = line.split("\\s+");
            disconnectedQueries.add(new Pair<Integer, Integer>(Integer.parseInt(split[0]),
                Integer.parseInt(split[1])));
        }
        brDisconnected.close();

        // List of used queries
        List<Pair<Integer, Integer>> queries = new ArrayList<>();
        int nextConnectedQuery = 0;
        int nextDisconnectedQuery = 0;
        for (int i = 0; i < numQueries; ++i) {
            if (srcDestRand.nextDouble() < connectedQueryPercentage) {
                queries.add(connectedQueries.get(nextConnectedQuery++));
            } else {
                queries.add(disconnectedQueries.get(nextDisconnectedQuery++));                
            }
        }
        return queries;
    }

    private double getAverage() {
        System.out.println("BatchTimes.size: " + batchTimes.size());
        long sum = batchTimes.stream().mapToLong(Long::longValue).sum();
        return sum * 1.0 / batchTimes.size();
    }

    private void prepareAndExecuteExperiment() throws NumberFormatException, IOException {
        System.out.println("*** Graphflow: Continuous Shortest Path Experiment ***");
        System.out.println("*** Graphflow: ExecutorType: " + executorType.toString() + " ***");

        long beginTime = System.nanoTime();
        loadInitial();
        System.out.println("Initial graph load time (ms)\t" + String.format("%.2f",
            (System.nanoTime() - beginTime) / 1000000.0));

        beginTime = System.nanoTime();

        // prepare update queries, by randomly selecting from given files using given seeds!
        if(isWeighted) {
            prepareUpdateBatches();
        } else {
            prepareAddDeleteBatches();
        }

        System.out.println("Batches prep time (ms)\t" + String.format("%.2f",
            (System.nanoTime() - beginTime) / 1000000.0));


        // prepare query list, and register them for execution
        beginTime = System.nanoTime();
        prepareAndRegisterContinuousShortestPathQueries();
        System.out.println("Finished initializing! ");
        System.out.println("Initial differential time (ms)\t" + String.format("%.2f",
            (System.nanoTime() - beginTime) / 1000000.0));





        // Run the experiment!
        long experimentBeginTime = System.nanoTime();
        applyBatchesAndMeasure();
        double executionTime = (System.nanoTime() - experimentBeginTime) / 1000000.0;


        // Reporting
        System.out.println("*** Experiment Finished ***");
        System.out.println("*** Executor Type: " + executorType.name() + " ***");
        System.out.println("total batch times = " + batchTimes.stream()
                        .mapToLong(Long::longValue).sum() / 1000000.0 + " ms");
        System.out.println("Average batch time = " + getAverage() / 1000000.0 + " ms.");
        System.out.println("Last batch time = " + batchTimes
                        .get(batchTimes.size() - 1) / 1000000.0 + " ms.");
        System.out.println("Execution time = " + executionTime + " ms.");
        if (ExecutorType.UNW_BASELINE == executorType) {
            System.out.println("ShortestPathExecutor.totalTimeTaken: " +
                ShortestPathExecutor.totalTimeTaken / 1000000.0 + " ms.");
        }
        if (printDistances) {
            System.out.println("Beginning Printing Distances For Each Batch");
            for (int i = 0; i < numBatches; ++i) {
                System.out.println("batch " + i + ": " + Arrays.toString(srcDstDistances.get(i).toArray()));
            }
        }
        System.out.println("End of Printing Distances For Each Batch");
        if (ExecutorType.BIDIR_UNWEIGHTED_DIFF_BFS == executorType ||
            ExecutorType.UNI_UNWEIGHTED_DIFF_BFS == executorType ||
            ExecutorType.UNIDIR_WEIGHTED_DIFF_BFS == executorType ||
            ExecutorType.UNIDIR_POSITIVE_WEIGHTED_DIFF_BFS == executorType ||
            ExecutorType.VARIABLE_LENGTH_PATH == executorType) {
            System.out.println("distances size = " + Arrays.toString(getSizesOfDistances()));
        }
    }

    public int[] getSizesOfDistances() {
        List<ContinuousShortestPathPlan> differentialPlans = ContinuousShortestPathsExecutor.getShortestPathPlans();
        int[] sizesArray = new int[differentialPlans.size()];
        for (int i=0; i < differentialPlans.size(); i++) {
            sizesArray[i] = ((ContinuousDiffBFSShortestPathPlan) differentialPlans.get(i)).getSizeOfDistances();
        }
        return sizesArray;
    }

    enum BatchType {
        ADDITION,
        DELETION,
        UPDATE
    }

    class EdgeBatch {
        int[] fromVertexId;
        int[] toVertexId;
        double[] weight;
        BatchType[] type;
        int size = 0;
        int currentEdgeIndex = 0;

        EdgeBatch(int batchSize) {
            this.size = batchSize;
            init();
        }

        void init() {
            this.toVertexId = new int[this.size];
            this.fromVertexId = new int[this.size];
            this.weight = new double[this.size];
            this.type = new BatchType[this.size];
        }

        void insertEdge(int fromVertex, int toVertex, BatchType type) {
            this.fromVertexId[currentEdgeIndex] = fromVertex;
            this.toVertexId[currentEdgeIndex] = toVertex;
            this.type[currentEdgeIndex] = type;
            this.currentEdgeIndex++;
        }

        void insertEdge(int fromVertex, int toVertex, double weight, BatchType type) {
            this.weight[currentEdgeIndex] = weight;
            insertEdge(fromVertex, toVertex, type);
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("EdgeBatch: size=");
            sb.append(size);
            sb.append(", edge=[");
            for (int i = 0; i < currentEdgeIndex; i++) {
                sb.append("[");
                sb.append(fromVertexId[i]);
                sb.append(",");
                sb.append(toVertexId[i]);
                sb.append(",");
                sb.append(weight[i]);
                sb.append(",");
                sb.append(type[i].toString());
                sb.append("]");
                if (i < currentEdgeIndex - 1) {
                    sb.append(", ");
                }
            }
            sb.append("]");
            return sb.toString();
        }
    }

    public static void main(String[] args) throws ParseException, NumberFormatException, IOException {

        CommandLine cmd = new DefaultParser().parse(getCommandLineOptions(), args);

        String baseDir = cmd.getOptionValue(ARG_BASE_DIR, DEFAULT_ARG_BASE_DIR);
        String graphFileToLoad = cmd.getOptionValue(ARG_GRAPH_FILE_TO_LOAD, DEFAULT_ARG_GRAPH_FILE_TO_LOAD);
        String connectedQueryFile = cmd.getOptionValue(ARG_CONNECTED_QUERY_FILE, DEFAULT_ARG_CONNECTED_QUERY_FILE);
        String disconnectedQueryFile = cmd.getOptionValue(ARG_DISCONNECTED_QUERY_FILE, DEFAULT_ARG_DISCONNECTED_QUERY_FILE);
        String addEdgesFile = cmd.getOptionValue(ARG_ADD_EDGES_FILE, DEFAULT_ARG_ADD_EDGES_FILE);
        String delEdgesFile = cmd.getOptionValue(ARG_DELETE_EDGES_FILE, DEFAULT_ARG_DELETE_EDGES_FILE);
        double deletionProbability = Double.parseDouble(cmd.getOptionValue(ARG_DELETION_PROBABILITY, DEFAULT_ARG_DELETION_PROBABILITY));
        int batchSize = Integer.parseInt(cmd.getOptionValue(ARG_BATCH_SIZE, DEFAULT_ARG_BATCH_SIZE));
        int numBatches = Integer.parseInt(cmd.getOptionValue(ARG_NUM_BATCHES, DEFAULT_ARG_NUM_BATCHES));
        int numQueries = Integer.parseInt(cmd.getOptionValue(ARG_NUM_QUERIES, DEFAULT_ARG_NUM_QUERIES));
        double connectedQueryPercentage = Double.parseDouble(cmd.getOptionValue(ARG_CONNECTED_QUERY_PERCENTAGE,
            DEFAULT_ARG_CONNECTED_QUERY_PERCENTAGE));
        ExecutorType executorType = ExecutorType.getFromCommandLineName(
            cmd.getOptionValue(ARG_EXECUTOR_TYPE, DEFAULT_ARG_EXECUTOR_TYPE));
        boolean isWeighted = executorType == ExecutorType.UNIDIR_WEIGHTED_DIFF_BFS || executorType ==
            ExecutorType.UNIDIR_POSITIVE_WEIGHTED_DIFF_BFS || executorType == ExecutorType.W_BASELINE
            || executorType == ExecutorType.DIJKSTRA;
        int addDeleteSeed = Integer.parseInt(cmd.getOptionValue(ARG_SEED_ADD_DELETE, DEFAULT_ARG_SEED_ADD_DELETE));
        int srcDestSeed = Integer.parseInt(cmd.getOptionValue(ARG_SEED_SRC_DST, DEFAULT_ARG_SEED_SRC_DST));
        int edgeWeightSeed = Integer.parseInt(cmd.getOptionValue(ARG_SEED_EDGE_WEIGHT, DEFAULT_ARG_SEED_EDGE_WEIGHT));
        int edgeGenSeed = Integer.parseInt(cmd.getOptionValue(ARG_SEED_EDGE_GEN, DEFAULT_ARG_SEED_EDGE_GEN));
        int edgeWeightRange = Integer.parseInt(cmd.getOptionValue(ARG_EDGE_WEIGHT_RANGE, DEFAULT_ARG_EDGE_WEIGHT_RANGE));
        boolean backtrack = Boolean.parseBoolean(cmd.getOptionValue(ARG_BACKTRACK, DEFAULT_ARG_BACKTRACK));
        boolean printDistances = Boolean.parseBoolean(cmd.getOptionValue(ARG_PRINT_DISTANCES, DEFAULT_ARG_PRINT_DISTANCES));
        Graph.getInstance().setSeed(edgeGenSeed);

        long beginTime = System.nanoTime();

        // create a new experiment
        EvaluatePathQueries experiment = new EvaluatePathQueries(baseDir, graphFileToLoad, connectedQueryFile, disconnectedQueryFile, addEdgesFile,
            delEdgesFile, deletionProbability, executorType, numQueries, connectedQueryPercentage, numBatches, batchSize,
            addDeleteSeed, srcDestSeed, edgeWeightSeed, isWeighted, edgeWeightRange, backtrack, printDistances);

        // run the experiment
        experiment.prepareAndExecuteExperiment();
        long endTime = System.nanoTime();
        System.out.println(experiment);
        System.out.println("Total time the entire experiment took: " + (endTime - beginTime)/1000000000.0 + " seconds" );
    }

    private static Options getCommandLineOptions() {
        Options options = new Options();
        options.addOption("help", false, "print this message");
        options.addOption(ARG_BASE_DIR, ARG_BASE_DIR, true, "base directory where the experimental " + "datasets are");
        options.addOption(ARG_GRAPH_FILE_TO_LOAD, ARG_GRAPH_FILE_TO_LOAD, true, "graph file to load and " + "deserialize");
        options.addOption(ARG_ADD_EDGES_FILE, ARG_ADD_EDGES_FILE, true, "file that contains edges to add " + "in batches");
        options.addOption(ARG_DELETE_EDGES_FILE, ARG_DELETE_EDGES_FILE, true, "file that contains edges to delete in batches"
            + " (usually the original file but shuffled)");
        options.addOption(ARG_DELETION_PROBABILITY, ARG_DELETION_PROBABILITY, true, "fraction of edges" + "to delete in batches.");
        options.addOption(ARG_BATCH_SIZE, ARG_BATCH_SIZE, true, "size of each batch in the experiment.");
        options.addOption(ARG_NUM_BATCHES, ARG_NUM_BATCHES, true, "number of batches to execute in the experiment.");
        options.addOption(ARG_NUM_QUERIES, ARG_NUM_QUERIES, true, "number of queries to execute in the experiment.");
        options.addOption(ARG_CONNECTED_QUERY_PERCENTAGE, ARG_CONNECTED_QUERY_PERCENTAGE, true, "percentage of queries that are connected.");

        options.addOption(ARG_SEED_ADD_DELETE, ARG_SEED_ADD_DELETE, true, "The seed to " +
            "use for add/delete random");
        options.addOption(ARG_SEED_SRC_DST, ARG_SEED_SRC_DST, true, "The seed to use " +
            "for choosing two random src/destination");
        options.addOption(ARG_SEED_EDGE_WEIGHT, ARG_SEED_EDGE_WEIGHT, true, "The seed to use " +
            "for choosing random weights");
        options.addOption(ARG_SEED_EDGE_GEN, ARG_SEED_EDGE_GEN, true, "The seed to use " +
            "for choosing random edges");
        options.addOption(ARG_EXECUTOR_TYPE, ARG_EXECUTOR_TYPE, true, "type of the cont. sp executor: Options are: "
            + "baseline/uni-unw-arr/uni-unw-map/bi-unw.");
        options.addOption(ARG_EDGE_WEIGHT_RANGE, ARG_EDGE_WEIGHT_RANGE, true, "number of edge " +
            "weights");
        options.addOption(ARG_BACKTRACK, ARG_BACKTRACK, true, "should do backtracking or not");
        options.addOption(ARG_PRINT_DISTANCES, ARG_PRINT_DISTANCES, true, "should print distances or not");
        return options;
    }
}
